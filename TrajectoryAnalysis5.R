                                        #This script has been changed to not count cells once their trajectory ends, even if they haven't reached the end of the device

                                        #V3 corrected how enrichment was calculated and modified script to take unequal numbers of paths into account
                                        #V4 adds the ability to analyze biased outputs
#V5 adds support for trajectories generated by the Qiu group tracking software

library(data.table)
library(ggplot2)
normalizeTrajectories=function(calibration,data,names,calibDist){
                                        #All raw .csv files should be of the format created by the ImageJ 'Manual Tracking' plugin
                                        #calibration: Vector of the path names for the files containing the calibration data for each video analyzed
                                        #data: a vector of vectors. Each vector is a vector of the path names of the files containing the data for a particular video
                                        #names: a vector of strings containing the names of the case demonstrated in each video
                                        #calibDist: distance between calibration points
    if(length(calibration)!=length(data)||length(data)!=length(names)){
        print("all inputs must have the same length")
        return(FALSE)
    }
    calibData=list()
    lengthCalibData=0
    calParams=list()
    lengthCalParams=0
    for(f in calibration){
        thisData=read.csv(f)
        print("read 0")
        thisData$Y=-1*thisData$Y #make it so increasing Y corresponds to upward motion
        lengthCalibData=lengthCalibData+1
        calibData[[lengthCalibData]]=thisData
        lengthCalParams=lengthCalParams+1
        calParams[[lengthCalParams]]=extractCalibrationInfo(thisData)
    }
    normData=list()
    lengthNormData=0
    longestTrackLength=0
    for(i in 1:length(calibration)){
        thisData=read.csv(data[[i]][1])
        print("read 1")
        thisData$Y=-1*thisData$Y
        if(length(data[[i]])>1){
            for(j in 2:length(data[[i]])){
                newTracks=read.csv(data[[i]][j])
                print("read 2")
                newTracks$Y=-1*newTracks$Y
                newTracks$Track.n.=newTracks$Track.n.+thisData$Track.n.[dim(thisData)[1]]
                thisData=rbind(thisData,newTracks)
            }
        }
        thisDataNorm=rotateAroundStart(thisData,-calParams[[i]]$tilt)
        thisDataNorm=calibDist*thisDataNorm/calParams[[i]]$ridgeDist
        thisData$X=thisDataNorm$X
        thisData$Y=thisDataNorm$Y
        thisData$Track.n.=factor(thisData$Track.n.)
        thisData=data.table(thisData)
        for(l in levels(thisData$Track.n.)){
            dimTrack=dim(thisData[Track.n.==l])
            if(dimTrack[1]>longestTrackLength){
                longestTrackLength=dimTrack[1]
            }
        }
        lengthNormData=lengthNormData+1        
        normData[[lengthNormData]]=thisData
    }
    deflPerRidge=list()
    cumulativeDeflection=list()
    lengthDeflPerRidge=0
    for(k in normData){
        thisCaseDefl=array(NA,c(k$Track.n.[length(k$Track.n.)],longestTrackLength-1))
        thisCaseCumulative=array(NA,c(k$Track.n.[length(k$Track.n.)],longestTrackLength))
        row=0
        for(track in levels(k$Track.n.)){
            row=row+1
            thisTrack=k[Track.n.==track,]
            thisTrackStart=thisTrack$Y[1]
            thisCaseCumulative[row,1]=0
            for(ridge in 2:length(thisTrack$Y)){
                thisCaseDefl[row,ridge-1]=thisTrack$Y[ridge]-thisTrack$Y[ridge-1]
                if(!is.na(thisTrack$Y[ridge])){
                    thisCaseCumulative[row,ridge]=thisTrack$Y[ridge]-thisTrackStart
                }
            }
        }
        lengthDeflPerRidge=lengthDeflPerRidge+1
        deflPerRidge[[lengthDeflPerRidge]]=thisCaseDefl
        cumulativeDeflection[[lengthDeflPerRidge]]=thisCaseCumulative
    }
                                        #Reformat some data and Make some ill plots
    plots=list()
    lengthPlots=0
    medianDefl=list()
    deflFrame=list()
    cumFrame=list()
    for(i in 1:length(names)){
        deflPerRidgeFrame=data.frame(ridge=c(),defl=c())
        cumDeflFrame=data.frame(ridge=c(),defl=c())
        medianDeflPerRidge=data.frame(ridge=c(1:dim(deflPerRidge[[i]])[2]))
        medianDeflPerRidge$defl=rep(NA,length(medianDeflPerRidge$ridge))
        medianDeflPerRidge$n=medianDeflPerRidge$defl
        for(j in medianDeflPerRidge$ridge){
            medianDeflPerRidge$defl[j]=median(deflPerRidge[[i]][,j],na.rm=TRUE)
            medianDeflPerRidge$n[j]=length(deflPerRidge[[i]][,j][!is.na(deflPerRidge[[i]][,j])])
            thisCumFrame=data.frame(ridge=j,defl=cumulativeDeflection[[i]][,j])
            thisRidgeFrame=data.frame(ridge=j,defl=deflPerRidge[[i]][,j])
            thisRidgeFrame=data.table(thisRidgeFrame)
            deflPerRidgeFrame=rbind(deflPerRidgeFrame,thisRidgeFrame[!is.na(defl),])
            thisCumFrame=data.table(thisCumFrame)
            cumDeflFrame=rbind(cumDeflFrame,thisCumFrame[!is.na(defl),])
            
        }
        deflPerRidgeFrame=data.table(deflPerRidgeFrame)
        deflPerRidgeFrame[,ridge:=factor(ridge)]
        medianDeflPerRidge=data.table(medianDeflPerRidge)
        medianDeflPerRidge[,ridge:=factor(ridge)]
        cumDeflFrame=data.table(cumDeflFrame)
        cumDeflFrame=cumDeflFrame[,ridge:=factor(ridge)]
        medianDefl[[i]]=medianDeflPerRidge
        deflFrame[[i]]=deflPerRidgeFrame
        cumFrame[[i]]=cumDeflFrame
        dev.new()
        p=ggplot(deflPerRidgeFrame,aes(x=ridge,y=defl))+geom_boxplot()+labs(title=names[i],x="Ridge No",y=expression("Deflection"*bgroup("(",mu*m,")")))
        print(p)
        lengthPlots=lengthPlots+1
        plots[[lengthPlots]]=p
        p2=ggplot(medianDeflPerRidge,aes(x=ridge,y=defl,color=n))+geom_point()+labs(title=paste(names[i]," medians only"),x="Ridge No",y=expression("Deflection"*bgroup("(",mu*m,")")),color="Number of samples")
        dev.new()
        print(p2)
        lengthPlots=lengthPlots+1
        plots[[lengthPlots]]=p2

        dev.new()
        p3=ggplot(cumDeflFrame,aes(x=ridge,y=defl))+geom_boxplot()+labs(title=paste(names[i]," cumulative deflection"),x="Ridge Number",y=expression("Deflection"*bgroup("(",mu*m,")")))
        print(p3)
        lengthPlots=lengthPlots+1
        plots[[lengthPlots]]=p3
    }
    return(list(names=names,calibData=calibData,calParams=calParams,normData=normData,deflPerRidge=deflPerRidge,medianDeflPerRidge=medianDefl,deflFrame=deflFrame,cumFrame=cumFrame))
}

extractCalibrationInfo=function(calData){
                                        #returns a named list containing the tilt angle and inter-ridge spacing indicated in the calibration data, which should be a data frame created by importing a manual tracking csv.
                                        #inter-ridge spacing will be given in pixels, tilt in radians ccw from horizontal left to right motion
    out=data.frame(tilt=NA,ridgeDist=NA)
    totalDiff=calData[dim(calData)[1],c("X","Y")]-calData[1,c("X","Y")]
                                        #Get Tilt
    if(abs(totalDiff$X)>abs(totalDiff$Y)){
        fit=lm(Y~X,calData)
        slope=fit$coefficients["X"]
        rawAngle=atan(slope)
        if(totalDiff$X>0){
                                        #objects moving left to right
            out$tilt=atan(slope)
        }else{
            out$tilt=pi+atan(slope)
        }
    }else{
        print("Insert code to deal with vertical videos")
    }
                                        #Get inter-ridge distance
    dists=c()
    for(i in 2:dim(calData)[1]){
        diffX=calData$X[i]-calData$X[i-1]
        diffY=calData$Y[i]-calData$Y[i-1]
        dists=c(dists,sqrt(diffX*diffX+diffY*diffY))
    }
    out$ridgeDist=mean(dists)
    return(out)
}

rotateAroundStart=function(points,angle){
                                        #rotate the points (given as x,y pairs in the points data frame, which must contain columns named X and Y) around the starting point by angle radians. the points will be translated such that the starting point is at 0,0.
                                        #Perform rotation around the bottom left corner of a rectangle which encloses all points. therefore results of arctan will be unambiguous
    tempOriginX=min(points$X)
    tempOriginY=min(points$Y)
    points$Y=points$Y-tempOriginY
    points$X=points$X-tempOriginX
    r=sqrt((points$X^2)+(points$Y^2))
    theta=atan(points$Y/points$X)
    newTheta=theta+angle
    print(newTheta)
    newY=r*sin(newTheta)
    newX=r*cos(newTheta)
    newX=newX-newX[1]
    newY=newY-newY[1]
    return(data.frame(X=newX,Y=newY))
}

estimateEnrichment=function(normalizedData,nOutlets,settingsPerOutlet){
    #settingsPerOutlet is the number of different resistance settings at each outlet. resistance is assummed to increase linearly with setting, so (R2)=2*R1, (R3)=3*R1, etc
    cumData=normalizedData$cumFrame
    data=data.table(cumData[[1]])
    data[,species:=1]
    if(length(cumData)>1){#make master data table
        for (i in 2:length(cumData)){
            data=rbind(data,cbind(cumData[[i]],data.frame(species=i)))
        }
    }
    data$ridge=as.numeric(as.character(data$ridge))

                                        #Do iteration here
    
    counts=array(dim=c(max(data$ridge),nOutlets,length(cumData))) #counts to be organized as counts[ridge,outlet,species]
    for(j in 1:max(data$ridge)){#divide the range of defl at each ridge into equal parts and count trajectories which lie in each portion
        thisRidge=data[ridge==j,]
        ridgeMin=min(thisRidge$defl)
        ridgeRange=max(thisRidge$defl)-ridgeMin
        outletWidth=ridgeRange/nOutlets
        outletBounds=c(0:nOutlets)*outletWidth+ridgeMin #what are the boundaries of each portion
        for(k in 1:nOutlets){
            thisOutlet=thisRidge[defl>=outletBounds[k] & defl<=outletBounds[k+1],] #Cells will be double counted on boundaries. Shouldn't happen much
            
            for(l in 1:length(cumData)){
                                        #get/save counts of each species at this outlet/ridge
                counts[j,k,l]=length(thisOutlet[species==l,species])
            }
        }
    }
                                        #calculate enrichment for all species for each ridge at each outlet
    enrichment=data.table(data.frame(ridge=c(),outlet=c(),species=c(),enrichment=c()))
    for(ridge in 1:max(data$ridge)){
        speciesTotals=rep(0,length(cumData))
        for(species in 1:length(cumData)){
            speciesTotals[species]=sum(counts[ridge,,species])
        }
        for(outlet in 1:nOutlets){
            theseCounts=counts[ridge,outlet,]
            thesePercents=theseCounts/sum(theseCounts)
            for(species in 1:length(cumData)){
                for(species2 in 1:length(cumData))
                    if(species2!=species){
                                        #append row
                    newRow=data.frame(ridge=ridge,outlet=outlet,species1=species,species2=species2,species1Count=theseCounts[species],species2Count=theseCounts[species2],enrichment=(theseCounts[species]/theseCounts[species2])/(speciesTotals[species]/speciesTotals[species2]))
                enrichment=rbind(enrichment,newRow)
                }
            }
        }
    }

enrichment[,ridge:=factor(ridge)]
enrichment[,outlet:=factor(outlet)]
    enrichment[,species1:=factor(species1)]
    enrichment[,species2:=factor(species2)]
return(list(counts=counts,enrichment=enrichment))
}

plotCumSideBySide=function(normData,maxRidge=NA){
    graphics.off()
    plotFrame=cbind(normData$cumFrame[[1]],data.frame(cell=normData$names[[1]]))
    for(i in 2:length(normData$names)){
        plotFrame=rbind(plotFrame,cbind(normData$cumFrame[[i]],data.frame(cell=normData$names[[i]])))
    }
    if(!is.na(maxRidge)){
        plotFrame=data.table(plotFrame)
        plotFrame[,ridge:=as.numeric(as.character(ridge))]
        plotFrame=plotFrame[ridge<=maxRidge]
        plotFrame[,ridge:=factor(ridge)]
    }
    p=ggplot(plotFrame,aes(x=ridge,y=defl,fill=cell))+labs(x="Ridge Number",y=expression("Deflection"*bgroup("(",mu*m,")")))+geom_boxplot()+theme_classic()+theme(text=element_text(size=25),title=element_text(size=25),legend.title=element_blank())
    if(length(normData$names)<3){
        p=p+scale_fill_manual(values=c("grey","white"))
    }
    return(p)
}
extractPathsQiu=function(matDataPath){
    library(R.matlab)
    print("reading mat file")
    matData=readMat(matDataPath)
    print("done reading mat file")
    numPoints=dim(matData$all.cells)[3]
    allData=data.table(data.frame(cell.index=rep(as.numeric(NA),numPoints),event.index=rep(as.numeric(NA),numPoints),frame.index=rep(as.numeric(NA),numPoints),x=rep(as.numeric(NA),numPoints),y=rep(as.numeric(NA),numPoints),r=rep(as.numeric(NA),numPoints),p=rep(as.numeric(NA),numPoints),c=rep(as.numeric(NA),numPoints),mu=rep(as.numeric(NA),numPoints),sigma=rep(as.numeric(NA),numPoints)))
    for(i in 1:numPoints){
        allData[i,names(allData):=matData$all.cells[,,i][1:10]]
    }
    allData[,cell.index:=factor(cell.index)]
    for(cell in levels(allData$cell.index)){
        thisCell=allData[cell.index==cell]
        dists=c()
        angles=c()
        xdiffs=c()
        ydiffs=c()
        speeds=c()
        for(j in 1:length(thisCell$x)-1){
            d=sqrt(((thisCell$x[j+1]-thisCell$x[j])^2)+((thisCell$y[j+1]-thisCell$y[j])^2))
            dists=c(dists,d)
            speeds=c(speeds,d/(thisCell$frame.index[j+1]-thisCell$frame.index[j]))
            a=atan2((thisCell$y[j+1]-thisCell$y[j]),(thisCell$x[j+1]-thisCell$x[j]))
            angles=c(angles,a)
            xdiffs=c(xdiffs,thisCell$x[j+1]-thisCell$x[j])
            ydiffs=c(ydiffs,thisCell$y[j+1]-thisCell$y[j])
        }
        plotData=data.frame(xdiffs=xdiffs,ydiffs=ydiffs,angles=angles,dists=dists,index=c(1:length(dists)))
        graphics.off()
        p1=ggplot(plotData)+geom_path(aes(x=index,y=dists))+labs(title="dists")
        p2=ggplot(plotData)+geom_path(aes(x=index,y=angles))+labs(title="angles")
        p3=ggplot(plotData)+geom_path(color="red",aes(x=index,y=xdiffs))+geom_path(color="blue",aes(x=index,y=ydiffs))+labs(title="diffs")
        p4=ggplot(plotData)+geom_path(aes(x=index,y=speeds))+labs(title="speeds")
        if(TRUE){
            dev.new()
            print(p1)
            dev.new()
            print(p2)
            dev.new()
            print(p3)
            dev.new()
            print(p4)
            print("hit enter to continue")
            readLines(n=1)
        }
    }
    return(allData)
}
